#!/usr/bin/env bash
# This script was generated by bashly 1.0.1 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  # echo "# this file is located in 'src/root_command.sh'"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args

  ip_central="155.210.154.100"
  ip=${args[--hostname]}
  target=${args[target]}
  wake=${args[--wake-up]}
  shutdown=${args[--shutdown]}
  if [[ $wake ]]; then
      username=${args[--wake-up]}
  elif [[ $shutdown ]]; then
      username=${args[--shutdown]}
  fi
  list=${args[--list]}
  users=${args[--users]}
  power_on=${args[--wake-up]}
  power_off=${args[--shutdown]}

  target_list=()

  red='\e[0;31m'
  green='\e[0;32m'
  noc='\e[0m'

  check_address () {
      ttl=$(ping -c 1 -W 2 $1 2>&1 | grep -o 'ttl=[0-9]*' | cut -d= -f2)
      if [[ $ttl =~ ^[0-9]+$ ]]; then

          host=$(host $1 2>/dev/null | grep -oE '[^ ]+$' | cut -d'.' -f1)
          if echo $host | grep "NXDOMAIN" > /dev/null 2>&1; then
              host='unknown'
          fi

          if [ $ttl -le 64 ]; then
              status="${green}Unix/Linux${noc}"
          elif [ $ttl -le 128 ]; then
              status="${green}Windows${noc}"
          elif [ $ttl -le 254 ]; then
              status="${green}Solaris/AIX${noc}"
          fi
      else
          host="unknown"
          status="${red}DOWN${noc}"
      fi

      echo -e "$host $1 $status"
  }

  check_users () {
      if ping -c 1 -W 2 $1 > /dev/null 2>&1; then
          ssh -qt a798095@155.210.154.201 "who | cut -f1 -d' ' | sort -u" |
          while read user; do
              echo $1 $user
          done
      fi
  }

  get_host () {
      host=$(host $1 2>/dev/null | grep -oE '[^ ]+$' | cut -d'.' -f1)
      if echo $host | grep "NXDOMAIN" > /dev/null 2>&1; then
          echo "no se encontro el nombre del host"
          exit 1
      fi
      echo $host
  }

  if [[ $ip ]]; then
  # tener solo en cuenta el hostname
      target_list+=("$ip")
  else

  # tener en cuenta el target
      if [ -f $target ]; then
          while IFS= read -r -d $'\n' linea; do
              target_list+=("$linea")
          done < $target
      else

          echo "Fichero de ips ausente"
          exit 1

      fi
  fi

  if [[ $list ]]; then

      for addr in "${target_list[@]}"; do
          if [[ $users ]]; then
              check_users $addr
          else

              check_address $addr
          fi
      done

  elif [[ $power_on ]]; then

      for addr in "${target_list[@]}"; do
          # Busqueda del nombre del host
          host=$(get_host $addr)
          echo ssh ${username}@${ip_central} "/usr/local/etc/wake -y ${host}"
          echo -e ${addr} is now ${green}up${noc}
      done

  elif [[ $power_off ]]; then

      for addr in "${target_list[@]}"; do
          # Prueba de conexion con el target
          if ! ping -c 1 -W 2 $addr > /dev/null 2>&1; then
              echo "can't connect to: $addr"
              break
          fi
          # Busqueda del nombre del host
          host=$(get_host $addr)

          # comprobar el numero de usuarios conectados a la maquina
          users_connected=$(ssh -qt ${username}@${addr} "who | cut -f1 -d' ' | sort -u")
          num_users=$(echo "$users_connected" | wc -l)
          if [ $num_users -gt 1 ]; then
              echo "La maquina esta siendo usada por mas de un usuario"
              exit 0
          elif ! echo "$users_connected" | grep -qw "$username"; then
              echo "La maquina esta siendo usada por otra persona"
              exit 0
          fi

          # comprobar que no haya maquinas en ejecucion
          vm_running_orig=$(ssh -qt ${username}@${addr} "virsh -c qemu:///system list | grep -v '^$' | tail -n +3")
          vm_running=()

          # crea una lista de los elementos validos de la lista original
          echo "$vm_running_orig" | while read -r -d $'\n' line; do
              if ! [ -z "$line" ]; then
                  vm_running+=("$linea")
              fi
          done

          # comprueba si hay maquinas virtuales en ejecucion
          if [ ${#vm_running[@]} -eq 1 ]; then
              echo "Hay ${#vm_running[@]} maquina virtual ejecutandose"
              exit 0
          elif [ ${#vm_running[@]} -gt 1 ]; then
              echo "Hay ${#vm_running[@]} maquinas virtuales ejecutandose"
              exit 0
          fi

          echo ssh ${username}@${ip_central} "/usr/local/etc/shutdown.sh -y ${host}"
          echo -e ${addr} is now ${red}down${noc}
      done

  fi
}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
messylab_usage() {
  if [[ -n $long_usage ]]; then
    printf "messylab - Aplicacion para el manejo de los laboratorios\n"
    echo

  else
    printf "messylab - Aplicacion para el manejo de los laboratorios\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  messylab [TARGET] [OPTIONS]\n"
  printf "  messylab --help\n"
  printf "  messylab --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--list, -l"
    printf "    Lista los resultados para cada uno de los hosts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--hostname, -h REMOTE_HOST"
    printf "    Hostname para consultar\n"
    echo

    # :flag.usage
    printf "  %s\n" "--users, -u"
    printf "    Cambia el comportamiento para que liste los usuarios conectados\n"
    echo

    # :flag.usage
    printf "  %s\n" "--wake-up, -w USERNAME"
    printf "    Despierta todas las maquinas del LABORATORIO proporcionadas\n"
    echo

    # :flag.usage
    printf "  %s\n" "--shutdown, -s USERNAME"
    printf "    Apaga todas las maquinas del LABORATORIO proporcionadas\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TARGET"
    printf "    Labs filename\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  messylab -l lab102.txt\n"
    printf "  messylab -luh 155.210.154.100\n"
    printf "  messylab -wh 155.210.154.100\n"
    printf "  messylab -sh 155.210.154.100\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help)
        long_usage=yes
        messylab_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v ping >/dev/null 2>&1; then
    deps['ping']="$(command -v ping | head -n1)"
  else
    printf "missing dependency: ping\n" >&2
    exit 1
  fi

  if command -v host >/dev/null 2>&1; then
    deps['host']="$(command -v host | head -n1)"
  else
    printf "missing dependency: host\n" >&2
    exit 1
  fi

  if command -v ssh >/dev/null 2>&1; then
    deps['ssh']="$(command -v ssh | head -n1)"
  else
    printf "missing dependency: ssh\n" >&2
    exit 1
  fi

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --list | -l)
        # :flag.conflicts
        for conflict in --wake-up --shutdown; do
          if [[ -n "${args[$conflict]:-}" ]]; then
            printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict" >&2
            exit 1
          fi
        done

        # :flag.case_no_arg
        args['--list']=1
        shift
        ;;

      # :flag.case
      --hostname | -h)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--hostname']="$2"
          shift
          shift
        else
          printf "%s\n" "--hostname requires an argument: --hostname, -h REMOTE_HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --users | -u)
        # :flag.conflicts
        for conflict in --wake-up --shutdown; do
          if [[ -n "${args[$conflict]:-}" ]]; then
            printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict" >&2
            exit 1
          fi
        done

        # :flag.case_no_arg
        args['--users']=1
        shift
        ;;

      # :flag.case
      --wake-up | -w)
        # :flag.conflicts
        for conflict in --list --users; do
          if [[ -n "${args[$conflict]:-}" ]]; then
            printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict" >&2
            exit 1
          fi
        done

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--wake-up']="$2"
          shift
          shift
        else
          printf "%s\n" "--wake-up requires an argument: --wake-up, -w USERNAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --shutdown | -s)
        # :flag.conflicts
        for conflict in --list --users; do
          if [[ -n "${args[$conflict]:-}" ]]; then
            printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict" >&2
            exit 1
          fi
        done

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--shutdown']="$2"
          shift
          shift
        else
          printf "%s\n" "--shutdown requires an argument: --shutdown, -s USERNAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['target']+x} ]]; then

          args['target']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root")
      root_command
      ;;

  esac
}

initialize
run "$@"
